Task 3:

Why do we use concurrent execution (multithreading/multiprocessing, or the like)? List a fair few reasons.
-	 saa og si alle sanntidssystemer bruker kjører programmer paralelt?
- 	 utnytte moderne cpuer som har flere tråder

How can adding more concurrent tasks make programming simpler? 
-Gjør sanntidsprogging enklere
And how can it make programming more difficult? 

Task 4:
What are the differences between processes, threads, green threads, and coroutines?
- Process: OS-managed (possibly) truly concurrent, at least in the presence of suitable hardware support. Exist within their 
own address space.
- Thread: OS-managed, within the same address space as the parent and all its other threads. Possibly truly concurrent, and 
multi-tasking is pre-emptive.
- Green Thread: These are user-space projections of the same concept as threads, but are not OS-managed. Probably not truly 
concurrent, except in the sense that there may be multiple worker threads or processes giving them CPU time concurrently, 
so probably best to consider this as interleaved or multiplexed.
- Coroutines: Not OS-managed. Exactly threads, except co-operatively multitasking, and hence not truly concurrent.

C = threads
Python = green threads
Golang = cocoroutines
